# Virtual Machine 16
```msa;c
;// MIT License
;//
;// Copyright (c) 2025 Tristan Styles
;//
;// Permission is hereby granted, free of charge, to any person obtaining a copy
;// of this software and atsociated documentation files (the "Software"), to deal
;// in the Software without restriction, including without limitation the rights
;// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;// copies of the Software, and to permit persons to whom the Software is
;// furnished to do so, subject to the following conditions:
;//
;// The above copyright notice and this permission notice shall be included in all
;// copies or substantial portions of the Software.
;//
;// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;// SOFTWARE.
```
```msa;c
;// Version 0.4.0
```
## Description

**vm16** is a 16-bit virtual machine inspired by [DCPU-16](https://web.archive.org/web/20120509184912/http://0x10c.com/doc/dcpu-16.txt).

**N.B.** As an experiment in using markdown as source, this is a _very_ basic implementation with only `stdin`, `stdout` and `stderr` character i/o supported.

[msa (V1.2.0 or later)](https://github.com/stytri/msa) is used to compile assembly source files.
```msa
{$BYTEBITS=16}
{$BYTEFORMAT=HEXADECIMAL}
```
The emulator is written in C[23](https://en.wikipedia.org/wiki/C23_(C_standard_revision)).
```c
#include <stdint.h>
#include <inttypes.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
```
### Memory

**vm16** has a 16-bit address range; the address of the first instruction is taken from memory at address 0. All other memory is available for general use.

```msa
{$MEMORY=64Ki}
```
```c
#define MEMORY  0x10000ul
```
### Registers
```msa
{reg#%r}
```
There are 16 16-bit program accessable registers, 14 are general purpose:
```msa
	{R0:reg=0}
	{R1:reg}
	{R2:reg}
	{R3:reg}
	{R4:reg}
	{R5:reg}
	{R6:reg}
	{R7:reg}
	{R8:reg}
	{R9:reg}
	{RA:reg}
	{RB:reg}
	{RC:reg}
```
as **vm16** has no dedicated Stack Pointer (`SP`) we use register 13 as `SP`.
```msa
	{SP:reg=13}
```
```c
	#define SP reg[reg_SP]
```
and, as this also affects subroutine call/return, we designate register `RC` as the Return Counter in which we store the return address; this can then be pushed and popped to/from the stack at subroutine entry/exit if required.

The other 2 registers are dedicated:

`SF` is the Status Flags reg.
`PC` is the Program Counter.
```msa
	{SF:reg=14}
	{PC:reg=15}
```
```c
	#define SF reg[reg_SF]
	#define PC reg[reg_PC]
```
#### Status Flags
```msa
{flag#%i}
```
`Z` indicates a zero result from the last operation.
```msa
	{Z:flag=0x1}
```
`N` indicates a negative - i.e. high bit set - result from the last operation.
```msa
	{N:flag=0x2}
```
`C` indicates a carry occurred in the last operation.
```msa
	{C:flag=0x4}
```
`V` indicates an overflow occurred in the last operation.
```msa
	{V:flag=0x8}
```

##### composite flags

```msa
	{NZ:flag=0x3}
	{CZ:flag=0x5}
	{CN:flag=0x6}
	{CNZ:flag=0x7}
	{VZ:flag=0x9}
	{VN:flag=0xA}
	{VNZ:flag=0xB}
	{VC:flag=0xC}
	{VCZ:flag=0xD}
	{VCN:flag=0xE}
	{VCNZ:flag=0xF}
```

### Instruction Format

`OOOORRRRXXXXMMMM` `YYYYYYYYYYYYYYYY`

Where:
	`MMMM` is a 4 bit mode of operation
	`XXXX` is a 4 bit operand: either a literal value, or a register number
	`RRRR` is a 4 bit register number
	`OOOO` is a 4 bit operation code; there are 15 basic operations, and one programmable function.
	`YYYYYYYYYYYYYYYY` is an optional (depending on the mode) 16 bit literal value, or address.

#### Assembler Format

Basic form:

`OPERATION` `DESTINATION` `SOURCE`

See **Instruction Modes and Patterns** for all supported formats.

```msa
{opcode#%o}
```

#### MSA standard field variables

`$1` for field `O`
`$2` for field `R`
`$3` for field `X`
`$4` for field `M`
`$5` for field `Y`

#### MSA emit functions

```msa
{EMIT_ORXM_INSTRUCTION{
	$0++ @= ($1 << 12) | ($2 << 8) | ($3 << 4) | $4
}}
```
variant for instructions with a 'Y' field:
```msa
{EMIT_ORXM_Y_INSTRUCTION{
	EMIT_ORXM_INSTRUCTION,
	$0++ @= $5 & 0xFFFF
}}
```
variant for instructions with a register target and literal source:
```msa
{EMIT_ORXM_L_INSTRUCTION{
	$3 = $3 & 0xFFFF,
	($3 <= 0x000F) ? (
		$4 = 0, EMIT_ORXM_INSTRUCTION
	)!($3 >= 0xFFFF0) ? (
		$3 = ~$3,
		$4 = 1, EMIT_ORXM_INSTRUCTION
	)!(($3 & ($3 - 1)) == 0) ? (
		$3 = |$3 - 1,
		$4 = 2, EMIT_ORXM_INSTRUCTION
	)!(($3 & ($3 + 1)) == 0) ? (
		$3 = 16 - |$3,
		$4 = 3, EMIT_ORXM_INSTRUCTION
	)!(
		$5 = $3, $3 = $2,
		$4 = 0xB, EMIT_ORXM_Y_INSTRUCTION
	)
}}
```
variants for instructions with addresses:
```msa
{EMIT_ORXM_A_PLACEHOLDER{
	$0++ @= ($1 << 12),
	$0++ @= 0
}}
```
```msa
{EMIT_ORXM_A_INSTRUCTION{
	$5 ? (
		EMIT_ORXM_Y_INSTRUCTION
	)!(
		INVALID
	)
}}
```

#### Non-Instruction Patterns

###### set program address
```msa
	%i: {
		$0 = $1
	}
```
###### align program address
```msa
	{ALIGN}
	ALIGN%i: {
		$0 = $0 + ($1 - ($0 % $1))
	}
```
###### label
```msa
	%a: {
		@1 = $0
	}
```
###### label reference as data
```msa
	%a {
		$0++ @= 0,
		true
	}:{
		$1 = @1,
		$1 ? (
			$0++ @= $1
		)!(
			INVALID
		)
	}
```
###### integer data
```msa
	%i {
		$0++ @= $1
	}
```
##### Memory Segment Patterns

A basic way to maintain separate `CODE` and `DATA` address spaces: we simply swap the current address in `$0` as appropriate.

```msa
	{CODE}
	{DATA}
```
```msa
	CODE: {
		$90 ? (
			$91 = $0, $0 = $92,
			$90 = false
		)
	}
```
```msa
	CODE%i: {
		$90 ? (
			$91 = $0,
			$90 = false
		),
		$0 = $92 = $1
	}
```
```msa
	DATA: {
		!$90 ? (
			$92 = $0, $0 = $91,
			$90 = true
		)
	}
```
```msa
	DATA%i: {
		!$90 ? (
			$92 = $0,
			$90 = true
		),
		$0 = $91 = $1
	}
```

## Virtual Machine Implementation

#### Execute Instruction
```c
static int vm16(
	uint16_t   reg[16],
	uint16_t   mem[MEMORY],
	int	  (*fun)(
		uint16_t  c,
		uint16_t *b,
		uint16_t *a
	),
	FILE *trace
) {
	int rc = 1;
```
##### Decode Instruction
```c
	uint16_t       pc = PC;
	uint16_t const ir = mem[pc++];
	uint16_t const m  =  ir        & 0xF;
	uint16_t	   x  = (ir >>  4) & 0xF;
	uint16_t	   r  = (ir >>  8) & 0xF;
	uint16_t const o  = (ir >> 12) & 0xF;
	uint16_t	   y;
	uint16_t	  *ap;
	uint16_t	  *bp;
	uint32_t	   c;
```
**N.B.** Although this is a 16-bit machine, we use 32-bits when executing operations to simplify detection of over/under-flow conditions.

##### Instruction Modes and Patterns

###### generic patterns for single register and literal operand
```msa
	%o%r%i{
		EMIT_ORXM_L_INSTRUCTION
	}
```
```msa
	%o%r~%i{
		$3 = ~$3,
		EMIT_ORXM_L_INSTRUCTION
	}
```
```msa
	%o%r-%i{
		$3 = -$3,
		EMIT_ORXM_L_INSTRUCTION
	}
```
###### generic pattern for single register and address operand
```msa
	%o%r%a{
		EMIT_ORXM_A_PLACEHOLDER,
		true
	}:{
		$5 = @3, $3 = $2,
		EMIT_ORXM_A_INSTRUCTION
	}
```
###### instruction modes

**N.B.** The instruction decoder pulls double duty as the dissassembler.

In the following:
	**rR**  refers to the register indentified by the `R` field.
	**rX**  refers to the register indentified by the `X` field.
	**X**   refers to the literal value of the `X` field.
	**Y**   refers to the literal value of the `Y` field.
	**@**   indicates memory is accessed by the address given by the operand.
	**XXX** is a place holder for the operation.
```c
	switch(m) {
```
###### XXX rR X
```c
	case 0x0:
		c = x;
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s %"PRIu32"\n",
				PC, opcode_name[o], reg_name[r], c
			);
			return 1;
		}
		PC = pc;
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX rR C
where C = ~X
```c
	case 0x1:
		c = ~x & 0xFFFFu;
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s %"PRIu32"\n",
				PC, opcode_name[o], reg_name[r], c
			);
			return 1;
		}
		PC = pc;
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX rR B
where B = (1 << X)
```c
	case 0x2:
		c = 1u << x;
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s 0x%.4"PRIx32"\n",
				PC, opcode_name[o], reg_name[r], c
			);
			return 1;
		}
		PC = pc;
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX rR M
where M = (~0 >> X)
```c
	case 0x3:
		c = 0xFFFFu >> x;
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s 0x%.4"PRIx32"\n",
				PC, opcode_name[o], reg_name[r], c
			);
			return 1;
		}
		PC = pc;
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX rR rX
```msa
	%o%r%r {
		$4 = 0x4, EMIT_ORXM_INSTRUCTION
	}
```
```c
	case 0x4:
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s R%"PRIu16" R%"PRIu16"\n",
				PC, opcode_name[o], r, x
			);
			return 1;
		}
		PC = pc;
		c  =  reg[x];
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX rR rX++
```msa
	%o%r%r {
		$4 = 0x5, EMIT_ORXM_INSTRUCTION
	}
```
```c
	case 0x5:
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s R%"PRIu16" R%"PRIu16"++\n",
				PC, opcode_name[o], r, x
			);
			return 1;
		}
		PC = pc;
		c  =  reg[x]++;
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX rR @rX
```msa
	%o%r@%r {
		$4 = 0x6, EMIT_ORXM_INSTRUCTION
	}
```
```c
	case 0x6:
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s @%s\n",
				PC, opcode_name[o], reg_name[r], reg_name[x]
			);
			return 1;
		}
		PC = pc;
		x  =  reg[x];
		c  =  mem[x];
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX rR @rX++
```msa
	%o%r@%r++ {
		$4 = 0x7, EMIT_ORXM_INSTRUCTION
	}
```
```c
	case 0x7:
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s @%s++\n",
				PC, opcode_name[o], reg_name[r], reg_name[x]
			);
			return 1;
		}
		PC = pc;
		x  =  reg[x]++;
		c  =  mem[x];
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX @rR rX
```msa
	%o@%r%r {
		$4 = 0x8, EMIT_ORXM_INSTRUCTION
	}
```
```c
	case 0x8:
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s @%s %s\n",
				PC, opcode_name[o], reg_name[r], reg_name[x]
			);
			return 1;
		}
		PC = pc;
		c  =  reg[x];
		r  =  reg[r];
		ap = &mem[r];
		bp = ap;
		break;
```
###### XXX @rR++ rX
```msa
	%o@%r++%r {
		$4 = 0x9, EMIT_ORXM_INSTRUCTION
	}
```
```c
	case 0x9:
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s @%s++ %s\n",
				PC, opcode_name[o], reg_name[r], reg_name[x]
			);
			return 1;
		}
		PC = pc;
		c  =  reg[x]++;
		r  =  reg[r];
		ap = &mem[r];
		bp = ap;
		break;
```
###### XXX @--rR rX
```msa
	%o@--%r%r {
		$4 = 0xA, EMIT_ORXM_INSTRUCTION
	}
```
```c
	case 0xA:
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s @--%s %s\n",
				PC, opcode_name[o], reg_name[r], reg_name[x]
			);
			return 1;
		}
		PC = pc;
		c  =  reg[x];
		r  =--reg[r];
		ap = &mem[r];
		bp = ap;
		break;
```
###### XXX rR rX Y
```msa
	%o%r%r%i{
		$5 = $4,
		$4 = 0xB, EMIT_ORXM_Y_INSTRUCTION
	}
```
```msa
	%o%r%r~%i{
		$5 = ~$4,
		$4 = 0xB, EMIT_ORXM_Y_INSTRUCTION
	}
```
```msa
	%o%r%r-%i{
		$5 = -$4,
		$4 = 0xB, EMIT_ORXM_Y_INSTRUCTION
	}
```
```msa
	%o%r%r%a{
		EMIT_ORXM_A_PLACEHOLDER,
		true
	}:{
		$5 = @4,
		$4 = 0xB, EMIT_ORXM_A_INSTRUCTION
	}
```
```c
	case 0xB:
		y  =  pc++;
		y  =  mem[y];
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s %s %"PRIu16"\n",
				PC, opcode_name[o], reg_name[r], reg_name[x], y
			);
			return 1;
		}
		PC = pc;
		c  =  y;
		ap = &reg[r];
		bp = &reg[x];
		break;
```
###### XXX rR rX @Y
```msa
	%o%r%r@%i{
		$5 = $4,
		$4 = 0xC, EMIT_ORXM_A_INSTRUCTION
	}
```
```msa
	%o%r%r@%a{
		EMIT_ORXM_A_PLACEHOLDER,
		true
	}:{
		$5 = @4,
		$4 = 0xC, EMIT_ORXM_A_INSTRUCTION
	}
```
```c
	case 0xC:
		y  =  pc++;
		y  =  mem[y];
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s %s @%"PRIu16"\n",
				PC, opcode_name[o], reg_name[r], reg_name[x], y
			);
			return 1;
		}
		PC = pc;
		c  =  mem[y];
		ap = &reg[r];
		bp = &reg[x];
		break;
```
###### XXX rR @rX+Y
```msa
	%o%r@%r+%i{
		$5 = $4,
		$4 = 0xD, EMIT_ORXM_Y_INSTRUCTION
	}
```
```msa
	%o%r@%r-%i{
		$5 = -$4,
		$4 = 0xD, EMIT_ORXM_Y_INSTRUCTION
	}
```
```msa
	%o%r@%a+%r{
		EMIT_ORXM_A_PLACEHOLDER,
		true
	}:{
		$5 = @3, $3 = $4,
		$4 = 0xD, EMIT_ORXM_A_INSTRUCTION
	}
```
```msa
	%o%r@%i+%r{
		$5 = $3, $3 = $4,
		$4 = 0xD, EMIT_ORXM_A_INSTRUCTION
	}
```
```c
	case 0xD:
		y  =  pc++;
		y  =  mem[y];
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s %s @%s+%"PRIu16"\n",
				PC, opcode_name[o], reg_name[r], reg_name[x], y
			);
			return 1;
		}
		PC = pc;
		x  =  reg[x];
		c  =  mem[x + y];
		ap = &reg[r];
		bp = ap;
		break;
```
###### XXX @Y rR rX
```msa
	%o@%i%r%r{
		$5 = $2, $2 = $3, $3 = $4,
		$4 = 0xE, EMIT_ORXM_A_INSTRUCTION
	}
```
```msa
	%o@%a%r%r{
		EMIT_ORXM_A_PLACEHOLDER,
		true
	}:{
		$5 = @2, $2 = $3, $3 = $4,
		$4 = 0xE, EMIT_ORXM_A_INSTRUCTION
	}
```
```c
	case 0xE:
		y  =  pc++;
		y  =  mem[y];
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s @%"PRIu16" %s %s\n",
				PC, opcode_name[o], y, reg_name[r], reg_name[x]
			);
			return 1;
		}
		PC = pc;
		c  =  reg[x];
		ap = &mem[y];
		bp = &reg[r];
		break;
```
###### XXX @rR+Y rX
```msa
	%o@%r+%i%r{
		$5 = $3, $3 = $4,
		$4 = 0xF, EMIT_ORXM_Y_INSTRUCTION
	}
```
```msa
	%o@%r-%i%r{
		$5 = -$3, $3 = $4,
		$4 = 0xF, EMIT_ORXM_Y_INSTRUCTION
	}
```
```msa
	%o@%i+%r%r{
		$5 = $2, $2 = $3, $3 = $4,
		$4 = 0xF, EMIT_ORXM_A_INSTRUCTION
	}
```
```msa
	%o@%a+%r%r{
		EMIT_ORXM_A_PLACEHOLDER,
		true
	}:{
		$5 = $2, $2 = $3, $3 = $4,
		$4 = 0xF, EMIT_ORXM_A_INSTRUCTION
	}
```
```c
	case 0xF:
		y  =  pc++;
		y  =  mem[y];
		if(trace) {
			fprintf(trace,
				"%.6"PRIu16": %s @%s+%"PRIu16" %s\n",
				PC, opcode_name[o], reg_name[r], y, reg_name[x]
			);
			return 1;
		}
		PC = pc;
		c  =  reg[x];
		r  =  reg[r];
		ap = &mem[r + y];
		bp = ap;
		break;
```
```c
	}
```
##### Operation Execution
```c
	uint32_t b = *bp;
	uint32_t a;
	switch(o) {
```
`a` is the result, `b` and `c` are the operands.

###### MOV

Move data.
```msa
	{MOV:opcode=0x0}
```
```c
	case opcode_MOV:
		if(ap != bp) {
			*ap = (uint16_t)(a = b);
			*bp = (uint16_t)c;
		} else {
			*ap = (uint16_t)(a = c);
		}
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		break;
```
###### AND

Bitwise AND of the operands.
```msa
	{AND:opcode=0x1}
```
```c
	case opcode_AND:
		a = b & c;
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		break;
```
###### XOR

Bitwise eXclusive OR of the operands.
```msa
	{XOR:opcode=0x2}
```
```c
	case opcode_XOR:
		a = b ^ c;
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		break;
```
###### IOR

Bitwise Inclusive OR of the operands.

```msa
	{IOR:opcode=0x3}
```
```c
	case opcode_IOR:
		a = b | c;
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		break;
```
###### SHL

Left Shift of the first operand by the second operand.
```msa
	{SHL:opcode=0x4}
```
```c
	case opcode_SHL:
		a = b << (c & 15);
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF))              SF |= flag_Z;
		if(a & (1 << 15))              SF |= flag_N;
		if((b >> (~c & 15)) & 0xFFFFu) SF |= flag_V;
		break;
```
###### SHR

Right Shift of the first operand by the second operand.
```msa
	{SHR:opcode=0x5}
```
```c
	case opcode_SHR:
		a = b >> (c & 15);
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF))              SF |= flag_Z;
		if(a & (1 << 15))              SF |= flag_N;
		if(b & (0xFFFFu >> (~c & 15))) SF |= flag_C;
		break;
```
###### ADD

Addition to the first operand of the second operand.
```msa
	{ADD:opcode=0x6}
```
```c
	case opcode_ADD:
		a = b + c;
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		if(a >> 16)       SF |= flag_V;
		break;
```
###### SUB

Subtraction from the first operand of the second operand.
```msa
	{SUB:opcode=0x7}
```
```c
	case opcode_SUB:
		a = b - c;
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		if(a >> 16)       SF |= flag_C;
		break;
```
###### MUL

Multiplication of the first operand by the second operand.
```msa
	{MUL:opcode=0x8}
```
```c
	case opcode_MUL:
		a = b * c;
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		if(a >> 16)       SF |= flag_V;
		break;
```
###### DIV

Division of the first operand by the second operand.
```msa
	{DIV:opcode=0x9}
```
```c
	case opcode_DIV:
		a = c ? b / c : 0;
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		if(c == 0)        SF |= flag_V;
		break;
```
###### MOD

Modulo of the first operand by the second operand.
```msa
	{MOD:opcode=0xA}
```
```c
	case opcode_MOD:
		a = c ? b % c : 0;
		*ap = (uint16_t)a;
		SF &= ~flag_VCNZ;
		if(!(a & 0xFFFF)) SF |= flag_Z;
		if(a & (1 << 15)) SF |= flag_N;
		if(c == 0)        SF |= flag_V;
		break;
```
###### IFB

Execute next instruction if bitwise AND of the operands is non-zero.
```msa
	{IFB:opcode=0xB}
```
```c
	case opcode_IFB:
		if((b & c) != 0) {
			break;
		}
		x = PC++;
		y = mem[x];
		if((y & 0xF) > 0xA) {
			PC++;
		}
		break;
```
###### IFC

Execute next instruction if bitwise AND of the operands is zero.

```msa
	{IFC:opcode=0xC}
```
```c
	case opcode_IFC:
		if((b & c) == 0) {
			break;
		}
		x = PC++;
		y = mem[x];
		if((y & 0xF) > 0xA) {
			PC++;
		}
		break;
```
###### IFF

Execute next instruction if bitwise AND of the operands is the same as the second operand.
```msa
	{IFF:opcode=0xD}
```
```c
	case opcode_IFF:
		if((b & c) == c) {
			break;
		}
		x = PC++;
		y = mem[x];
		if((y & 0xF) > 0xA) {
			PC++;
		}
		break;
```
###### IFN

Execute next instruction if bitwise AND of the operands is not same as the second operand.
```msa
	{IFN:opcode=0xE}
```
```c
	case opcode_IFN:
		if((b & c) != c) {
			break;
		}
		x = PC++;
		y = mem[x];
		if((y & 0xF) > 0xA) {
			PC++;
		}
		break;
```
###### FUN

Execute a host function; behaviour is implementation defined.
```msa
	{FUN:opcode=0xF}
```
```c
	case opcode_FUN:
		if(fun) {
			rc = fun((uint16_t)c, bp, ap);
		}
		break;
```
```c
	}
```
```c
	return rc;
}
```

##### Synthetic Instruction Patterns

###### POP

Pops a register from the stack.
```msa
	{POP}
	POP%r {
		$2 = $1, $3 = SP, $1 = MOV,
		$4 = 0x7, EMIT_ORXM_INSTRUCTION
	}
```
###### PSH
```msa
	{PSH}
```
Pushes a register onto the stack.
```msa
	PSH%r {
		$2 = SP, $3 = $1, $1 = MOV,
		$4 = 0xA, EMIT_ORXM_INSTRUCTION
	}
```
Pushes an integer onto the stack.
```msa
	PSH%i {
		$2 = SP, $3 = $1, $1 = MOV,
		$4 = 0xA, EMIT_ORXM_L_INSTRUCTION
	}
```
Pushes an address onto the stack.
```msa
	PSH%a {
		$2 = SP, $3 = $1, $1 = MOV,
		$4 = 0xA, EMIT_ORXM_A_INSTRUCTION
	}
```
###### JMP

Jumps by assigning the destination address to PC.
```msa
	{JMP}
	JMP%a {
		EMIT_ORXM_A_PLACEHOLDER,
		true
	}:{
		$5 = @1,
		$2 = $3 = PC, $1 = MOV,
		$4 = 0xB, EMIT_ORXM_A_INSTRUCTION
	}
```
###### JSR

Jumps to SubRoutine address by saving the current PC in a register and assigning the subroutine address to PC.
```msa
	{JSR}
	JSR%r%a {
		EMIT_ORXM_A_PLACEHOLDER,
		true
	}:{
		$5 = @2,
		$2 = $1, $3 = PC, $1 = MOV,
		$4 = 0xB, EMIT_ORXM_A_INSTRUCTION
	}
```
###### RET
```msa
	{RET}
```
Return from sub routine by assigning the return register to PC.
```msa
	RET%r {
		$2 = PC, $3 = $1, $1 = MOV,
		$4 = 0x4, EMIT_ORXM_INSTRUCTION
	}
```
Return from sub routine by popping from the stack to PC.
```msa
	RET {
		$2 = PC, $3 = SP, $1 = MOV,
		$4 = 0x7, EMIT_ORXM_INSTRUCTION
	}
```
###### BRA

Branches to an address by applying an offset to PC.
```msa
	{BRA}
	BRA%a {
		$5 = @1,
		($5 && ($5 < $0)) ? (
			$1 = SUB, $2 = PC,
			$3 = ($0 + 1) - $5,
			($3 <= 0x000F) ? (
				$4 = 0, EMIT_ORXM_INSTRUCTION
			)!($3 >= 0xFFF0) ? (
				$3 = ~$3,
				$4 = 1, EMIT_ORXM_INSTRUCTION
			)!(($3 & ($3 - 1)) == 0) ? (
				$3 = |$3 - 1,
				$4 = 2, EMIT_ORXM_INSTRUCTION
			)!(($3 & ($3 + 1)) == 0) ? (
				$3 = 16 - |$3,
				$4 = 3, EMIT_ORXM_INSTRUCTION
			)!(
				$5 = ($0 + 2) - $5, $3 = $2,
				$4 = 0xB, EMIT_ORXM_Y_INSTRUCTION
			),
			false
		)!(
			EMIT_ORXM_A_PLACEHOLDER,
			true
		)
	}:{
		$5 = @1,
		$5 ? (
			$2 = $3 = PC,
			($5 < $0) ? (
				$1 = SUB,
				$5 = ($0 + 2) - $5
			)!(
				$1 = ADD,
				$5 = $5 - ($0 + 2)
			),
			$4 = 0xB, EMIT_ORXM_A_INSTRUCTION
		)!(
			INVALID
		)
	}
```
###### HLT

Halts program execution.
```msa
	{HLT}
	HLT%r {
		$2 = $1, $3 = 0xFFFF, $1 = FUN,
		EMIT_ORXM_L_INSTRUCTION
	}
```

## Virtual Machine Emulator

```c
static uint16_t *mem	 = nullptr;
static uint16_t  reg[16] = {};
```

#### FUNction Implementation
```c
static int host_function(uint16_t c, uint16_t *b, uint16_t *a) {
	switch(c) {
	case 0x0000u: *a = fgetc(stdin); break;
	case 0x0001u: *a = fputc(*b, stdout); break;
	case 0x0002u: *a = fputc(*b, stderr); break;
	case 0xFFFFu: return -*b;
	default	 : return -1;
	}
	return 1;
}
```

#### main
```c
int main(int argc, char *argv[]) {
```

##### Check program arguments
```c
	uint64_t max_cycles = 0;
	FILE *trace = nullptr;
	bool debug = false;
	char *args = nullptr;
	int argi = 1;
	while(argi < argc) {
		args = argv[argi];
```
###### maximum cycle count
```c
		if(strcmp(args, "-c") == 0) {
			if(++argi < (argc - 1)) {
				args = argv[argi++];
				max_cycles = strtoull(args, &args, 0);
				switch(*args) {
				case 'T': max_cycles *= 1024; [[fallthrough]];
				case 'G': max_cycles *= 1024; [[fallthrough]];
				case 'M': max_cycles *= 1024; [[fallthrough]];
				case 'K': max_cycles *= 1024;
				}
			}
			continue;
		}
```
###### program execution trace
```c
		if(strcmp(args, "-t") == 0) {
			if(++argi < (argc - 1)) {
				args = argv[argi++];
				if(trace && (trace != stdout)) {
					fclose(trace);
				}
				trace = strcmp(args, "-") ? fopen(args, "w") : stdout;
				if(!trace) {
					perror(args);
				}
				debug = false;
			}
			continue;
		}
```
###### enable debug
```c
		if(strcmp(args, "-d") == 0) {
			argi++;
			if(trace && (trace != stdout)) {
				fclose(trace);
			}
			trace = stdout;
			debug = true;
			continue;
		}
```
###### command line help
```c
		if(strcmp(args, "-h") == 0) {
			argi++;
			goto help;
		}
```
###### anything else is considered a filename
```c
		break;
	}
	if((argc - argi) != 1) {
help:
		printf("use: %s [OPTIONS] FILE\n", argv[0]);
		puts("OPTIONS:");
		puts("\t-c NUM	stop after NUM cycles");
		puts("\t-t		enable trace");
		puts("\t-d		enable debug");
		return EXIT_FAILURE;
	}
```
##### Allocate memory
```c
	mem = calloc(MEMORY, sizeof(uint16_t));
	if(!mem) {
		perror("");
		abort();
	}
```
##### Load a binary file
```c
	FILE *f = fopen((args = argv[argi]), "rb");
	int failed = !f;
	if(!failed) {
		fread(mem, sizeof(uint16_t), MEMORY, f);
		failed = ferror(f);
		fclose(f);
		if(failed) {
			perror(args);
			return EXIT_FAILURE;
		}
	}
```
##### Execute the virtual machine
```c
	int rc;
	bool step = debug;
	bool skip = debug;
	uint16_t breakpoint[16];
	size_t n_breakpoints = 0;
```
###### execute instructions
```c
	PC = mem[0];
	while(skip
		|| ((--max_cycles != 0)
			 && ((rc = vm16(reg, mem, host_function, nullptr)) > 0))
	) {
		skip = false;
		if(!trace) {
			continue;
		}
		size_t i;
		if(!debug || step) {
```
###### output registers for trace and debug
```c
			static uint16_t old_reg[16];
			for(i = 0; i < 16; i++) {
				if((i % 4) == 0) {
					fputc('\n', trace);
				}
				fprintf(trace, "%s:0x%.4"PRIx16"(%5"PRIu16")", reg_name[i], reg[i], reg[i]);
				if(old_reg[i] != reg[i]) {
					old_reg[i] = reg[i];
					fputc('*', trace);
				} else {
					fputc(' ', trace);
				}
				fputc(' ', trace);
			}
			fputc('\n', trace);
			fputc((SF & flag_V) ? 'V' : '_', trace);
			fputc((SF & flag_C) ? 'C' : '_', trace);
			fputc((SF & flag_N) ? 'N' : '_', trace);
			fputc((SF & flag_Z) ? 'Z' : '_', trace);
			fputc('\n', trace);
			vm16(reg, mem, host_function, trace);
			if(!debug) {
				continue;
			}
		}
```
###### debug breakpoints
```c
		for(i = 0; !step && (i < n_breakpoints); i++) {
			skip = step = (breakpoint[i] == PC);
		}
		if(skip || !step) {
			continue;
		}
```
###### debug command line
```c
		char	 buf[BUFSIZ];
		char	*s;
		uint16_t x;
		putchar('>');
		putchar(' ');
		s = gets_s(buf, sizeof(buf));
		if(!s) {
			perror("");
			break;
		}
		for(; *s && !isgraph(*s); s++){;}
		switch(*s) {
```
step one instruction
```c
		case 's': case '\0':
			break;
```
set breakpoint
```c
		case 'b':
			switch(*(s + 1)) {
```
set breakpoint
```c
			default :
				if(n_breakpoints >= (sizeof(breakpoint)/sizeof(*breakpoint))) {
					puts("too many breakpoints");
				}
				x = strtoul(s+1, &s, 0);
				if(!x) {
					x = PC;
				}
				breakpoint[n_breakpoints++] = x;
				skip = true;
				break;
```
clear breakpoint
```c
			case 'c':
				x = strtoul(s+2, &s, 0);
				if(!x) {
					x = PC;
				}
				for(i = 0; i < n_breakpoints; i++) {
					if(breakpoint[i] == x) {
						break;
					}
				}
				if(i < n_breakpoints) {
					for(size_t j; (j = i++) < n_breakpoints; ) {
						breakpoint[j] = breakpoint[i];
					}
					n_breakpoints--;
				}
				skip = true;
				break;
```
list breakpoints
```c
			case 'l':
				for(i = 0; i < n_breakpoints; i++) {
					printf("[%zu] %"PRIu16"\n", i, breakpoint[i]);
				}
				skip = true;
				break;
			}
			break;
```
continue running to next breakpoint or, termination
```c
		case 'c':
			step = false;
			skip = true;
			break;
```
run program from start
```c
		case 'r':
			step = false;
			skip = true;
			PC = mem[0];
			break;
```
quit
```c
		case 'q':
			goto quit;
```
display help for unknown commands
```c
		default :
			puts("commands:");
			puts("s            execute single instruction");
			puts("b            set breakpoint at current address");
			puts("b ADDRESS    set breakpoint at ADDRESS");
			puts("bc           clear breakpoint at current address");
			puts("bc ADDRESS   clear breakpoint at ADDRESS");
			puts("bl           list breakpoints");
			puts("c            continue from here");
			puts("r            run from start");
			skip = true;
			break;
		}
	}
```
##### Terminate the program
```c
quit:
	if(trace && (trace != stdout)) {
		fclose(trace);
	}
	return rc ? rc : EXIT_SUCCESS;
}
```

## Example Assembly Program

```asm
0x0000:
	_init

CODE 0x0010:                    ; set CODE address space
DATA 0x8000:                    ; set DATA address space

CODE:
putc:
	FUN R0 1                    ; write r0 to stdout

	RET RC                      ; register return

puts:
	PSH RC                      ; push return address
	PSH R1

	MOV R1 R0                   ; r1 = r0
	BRA puts$2                  ; branch to puts$2
puts$1:
		JSR RC putc             ; call putc
puts$2:
		MOV R0 @R1++            ; read character
		IFC SF Z                ; if zero flag not set
			BRA puts$1          ;   loop back

	POP R1
	RET                         ; pop return

DATA:
Hello$:
	'H', 'e', 'l', 'l', 'o', ' ',
	'W', 'o', 'r', 'l', 'd', '\n',
	0

CODE:
ALIGN 0x100:
main:
	PSH RC                      ; push return address

	MOV R0 Hello$               ; set string to print
	JSR RC puts                 ; call puts

	RET                         ; pop return

_init:
	MOV SP 0x0000               ; Stack Base - first stack entry will end up at 0xFFFF
	JSR RC main                 ; call main
	MOV R0 0                    ; exit code = 0
	HLT R0                      ; halt
```

## Build and Test

Uses [eb](https://github.com/stytri/eb) and [m (v4.0.0 or later)](https://github.com/stytri/m).

On the command line enter:
	`m vm16.md`
to create the **msa** file, and compile the **vm16** emulator.

To compile the example assembly program enter:
	`m vm16.md hello.vm16`
then enter:
	`vm16 hello.vm16`
to run it.

#### m rules:
```
[comment]: # (::build:msa:c)
[comment]: # ()
[comment]: # (::msa)
[comment]: # (:+  eb -t msa -l -x .msa -o $!.msa $!)
[comment]: # (:&  msa -s $^.h $!.msa)
[comment]: # ()
[comment]: # (::c)
[comment]: # (:+  eb -t c -l -x .c -o $!.c $!)
[comment]: # (:&  $CC $CFLAGS $XFLAGS $SMALL-BINARY)
[comment]: # (:+	  -include $^.h -o $+^ $"* $!.c)
[comment]: # ()
[comment]: # (::clean)
[comment]: # (:+  $RM *.msa *.lst *.asm *.h *.c *.vm16 $+^)
[comment]: # ()
[comment]: # (::-)
[comment]: # (:+  eb -t asm -l -x .asm -o $:.asm $!)
[comment]: # (:&  msa $"* -o $: $!.msa $:.asm)
[comment]: # ()
[comment]: # (::CFLAGS!CFLAGS)
[comment]: # (:+	  $CSTD -Wall -Wextra $INCLUDE)
[comment]: # ()
[comment]: # (::XFLAGS!XFLAGS)
[comment]: # (:+	  -DNDEBUG=1 -O3 -march=native)
[comment]: # ()
[comment]: # (::SMALL-BINARY)
[comment]: # (:+	  -fmerge-all-constants -ffunction-sections -fdata-sections)
[comment]: # (:+	  -fno-unwind-tables -fno-asynchronous-unwind-tables)
[comment]: # (:+	  -Wl,--gc-sections -s)
[comment]: # ()
[comment]: # (::CSTD!CSTD)
[comment]: # (:+	  -std=c23)
```
